# Codex リファクタリングワークフロー

## 準備段階

### 1. プロジェクト分析

- [x] 現在のプロジェクト構造の把握
- [x] 主要な問題点の特定
- [x] リファクタリング目標の設定

### 2. 環境準備

- [x] コンテキストファイルの作成
- [x] プロンプト例の準備
- [x] 実装ガイドラインの作成

## Phase 1: エンジン依存の分離

### Step 1: 抽象化インターフェースの設計

**Codex への依頼内容:**

```
以下のC#プロジェクトのDomain層からエンジン依存を分離するため、抽象化インターフェースを設計してください。

現在の問題:
- Domain層のIAiContextインターフェースがviaエンジン固有の型（GameObject, vec3）に依存
- ローカル環境でのテストが困難

目標:
- Domain層からviaエンジン型を完全に排除
- 抽象化インターフェースの強化

現在のコード:
[IAiContext.csの内容を貼り付け]

提案してください:
1. 新しい抽象化インターフェース（IGameObject, ITransform, Vector3等）
2. 段階的移行計画
```

**期待される成果:**

- IGameObject, ITransform, Vector3, Quaternion インターフェース
- 型変換拡張メソッド
- 移行計画

### Step 2: アダプター層の実装

**Codex への依頼内容:**

```
上記で設計した抽象化インターフェースに対応するアダプター層を実装してください。

viaエンジンの型:
- via.GameObject
- via.vec3
- via.quaternion
- via.Transform

実装してください:
1. ViaAdapter クラス
2. ViaTransform クラス
3. 型変換拡張メソッド
```

### Step 3: Domain 層の更新

**Codex への依頼内容:**

```
IAiContextインターフェースを新しい抽象化インターフェースを使用するように更新してください。

変更点:
- GameObject → IGameObject
- vec3 → Vector3
- quaternion → Quaternion

制約:
- 既存の機能を維持
- 段階的移行が可能
```

## Phase 2: コンポジション優先設計への移行

### Step 1: ビヘイビアコンポーネントの設計

**Codex への依頼内容:**

```
以下のC#プロジェクトの継承設計をコンポジション優先設計に変更するリファクタリングを提案してください。

現在の問題:
- TwinGoblinAIがBasicEnemyAIを継承している
- 複数の特殊エネミーに対応困難

目標:
- ビヘイビアコンポーネントの導入
- 継承からコンポジションへの変更

現在のコード:
[BasicEnemyAI.csとTwinGoblinAI.csの内容を貼り付け]

提案してください:
1. ビヘイビアコンポーネントの設計（IPairBehavior, IEnrageBehavior等）
2. コンポジション優先のTwinGoblinAI実装
3. 新エネミー追加時の拡張方法
```

### Step 2: TwinGoblinAI のリファクタリング

**Codex への依頼内容:**

```
TwinGoblinAIクラスをコンポジション優先設計に変更してください。

要求:
1. BasicEnemyAIの継承を削除
2. ビヘイビアコンポーネントを使用
3. 型安全性を向上

制約:
- 既存の機能を維持
- パフォーマンスを考慮
```

## Phase 3: ファクトリの拡張性改善

### Step 1: ビルダーパターンの導入

**Codex への依頼内容:**

```
EnemyFactoryクラスをビルダーパターンを使用して拡張性を向上させてください。

現在の問題:
- 新しいエネミータイプ追加時にEnumとビルダーを変更
- Open/Closed Principleに反している

目標:
- ビルダーパターンの導入
- 設定駆動設計の強化

現在のコード:
[EnemyFactory.csとEnemyUserData.csの内容を貼り付け]

提案してください:
1. ビルダーパターンの実装
2. 設定駆動のファクトリ設計
3. 新エネミー追加時の手順
```

### Step 2: 設定駆動設計の強化

**Codex への依頼内容:**

```
EnemyUserDataクラスを拡張性の高い設定駆動設計に変更してください。

目標:
- 新しいエネミータイプの追加を容易にする
- 型安全性を向上
- デザイナー向けパラメータ調整を維持

提案してください:
1. 設定クラスの設計
2. 型安全なファクトリ実装
3. 新エネミー追加時の手順
```

## Phase 4: テスト戦略の実装

### Step 1: テストアーキテクチャの設計

**Codex への依頼内容:**

```
このC#プロジェクトのテスト戦略を提案してください。

現在の問題:
- エンジン依存により単体テストが困難
- 統合テストのみで品質保証

目標:
- 各コンポーネントの単体テスト
- モックを使用したテスト
- 高いテストカバレッジ

提案してください:
1. テストアーキテクチャ
2. モック戦略
3. テストケース設計
```

### Step 2: モック実装の作成

**Codex への依頼内容:**

```
テスト用のモック実装を作成してください。

必要なモック:
1. MockGameObject
2. MockTransform
3. MockAIContext
4. MockNavigationSystem

要求:
- 抽象化インターフェースを実装
- テスト可能な状態管理
- 簡単な設定と検証
```

## 検証段階

### Step 1: 単体テストの実行

**Codex への依頼内容:**

```
リファクタリング後のコードに対する単体テストを作成してください。

テスト対象:
1. 新しい抽象化インターフェース
2. ビヘイビアコンポーネント
3. ファクトリクラス

要求:
- 高いテストカバレッジ
- エッジケースの考慮
- 明確なテスト名と説明
```

### Step 2: 統合テストの実行

**Codex への依頼内容:**

```
リファクタリング後のシステム全体の統合テストを作成してください。

テスト対象:
1. エネミー生成からAI実行までの流れ
2. イベント駆動の動作
3. パフォーマンス要件

要求:
- 実際の使用シナリオをカバー
- パフォーマンステスト
- エラーケースのテスト
```

## 完了段階

### Step 1: ドキュメント更新

**Codex への依頼内容:**

```
リファクタリング後のプロジェクトドキュメントを更新してください。

更新内容:
1. 新しいアーキテクチャの説明
2. 使用方法の更新
3. 新エネミー追加手順
4. テスト実行方法

要求:
- 明確で分かりやすい説明
- 実用的な例
- トラブルシューティング
```

### Step 2: 移行ガイドの作成

**Codex への依頼内容:**

```
既存コードから新しいアーキテクチャへの移行ガイドを作成してください。

内容:
1. 段階的移行手順
2. 注意点と制約
3. よくある問題と解決方法
4. ロールバック手順

要求:
- 安全な移行手順
- リスクの最小化
- 段階的な検証
```

## 使用時の注意点

### 1. 段階的なアプローチ

- 一度に全てを変更せず、段階的にリファクタリング
- 各段階でテストを実行して動作確認
- 問題が発生した場合は前の段階に戻れるよう準備

### 2. 既存機能の保持

- 現在の AI 機能を維持しながら改善
- データ駆動設計の構造を保持
- デザイナー向けパラメータ調整を維持

### 3. パフォーマンス考慮

- リファクタリングによる性能劣化を避ける
- 型変換のオーバーヘッドを最小化
- 不要なオブジェクト生成を避ける

### 4. 可読性向上

- コードの可読性と保守性を向上させる
- 明確な命名規則を採用
- 適切なコメントを追加

### 5. テスト駆動

- 各段階でテストを追加・実行
- テストカバレッジを維持・向上
- 回帰テストを確実に実行
