# Codex リファクタリングプロンプト例

## プロンプト 1: エンジン依存の分離（Phase 1）

```
以下のC#プロジェクトのDomain層からエンジン依存を分離するリファクタリングを提案してください。

現在の問題:
- Domain層のIAiContextインターフェースがviaエンジン固有の型（GameObject, vec3）に依存
- ローカル環境でのテストが困難
- エンジン環境なしでの開発ができない

目標:
- Domain層からviaエンジン型を完全に排除
- 抽象化インターフェースの強化
- アダプター層の実装

制約:
- 既存のAI機能（パトロール、追跡、攻撃、帰還）を維持
- データ駆動設計（EnemyUserData, TwinGoblinUserData）を維持
- 段階的移行が可能

現在のコード:
[IAiContext.csの内容]

提案してください:
1. 新しい抽象化インターフェース（IGameObject, ITransform, Vector3等）
2. アダプター層の実装
3. 段階的移行計画
```

## プロンプト 2: コンポジション優先設計への移行（Phase 2）

```
以下のC#プロジェクトの継承設計をコンポジション優先設計に変更するリファクタリングを提案してください。

現在の問題:
- TwinGoblinAIがBasicEnemyAIを継承している
- 複数の特殊エネミーに対応困難
- 状態管理の複雑化

目標:
- ビヘイビアコンポーネントの導入
- 継承からコンポジションへの変更
- 型安全性の向上

現在のコード:
[BasicEnemyAI.csとTwinGoblinAI.csの内容]

提案してください:
1. ビヘイビアコンポーネントの設計（IPairBehavior, IEnrageBehavior等）
2. コンポジション優先のTwinGoblinAI実装
3. 新エネミー追加時の拡張方法
```

## プロンプト 3: ファクトリの拡張性改善（Phase 3）

```
以下のC#プロジェクトのファクトリパターンを拡張性の高い設計に変更するリファクタリングを提案してください。

現在の問題:
- 新しいエネミータイプ追加時にEnumとビルダーを変更
- Open/Closed Principleに反している
- 型安全性が不十分（キャストが必要）

目標:
- ビルダーパターンの導入
- 設定駆動設計の強化
- 新エネミー追加の容易化

現在のコード:
[EnemyFactory.csとEnemyUserData.csの内容]

提案してください:
1. ビルダーパターンの実装
2. 設定駆動のファクトリ設計
3. 新エネミー追加時の手順
```

## プロンプト 4: 全体アーキテクチャの改善

```
以下のC#プロジェクトの全体アーキテクチャを改善する包括的なリファクタリング計画を提案してください。

現在のアーキテクチャ:
- Domain層: ビジネスロジック（エンジン依存あり）
- Application層: ユースケース
- Infrastructure層: 実装詳細
- Data層: 設定データ
- Presentation層: UI
- Via層: エンジン接着層

目標:
- エンジン非依存のDomain層
- 新エネミー実装の容易化
- テスト容易性の向上
- 型安全性の向上

制約:
- 既存機能の保持
- データ駆動設計の維持
- 段階的移行

提案してください:
1. 新しいアーキテクチャ設計
2. 各層の責務とインターフェース
3. 移行計画とタイムライン
4. テスト戦略
```

## プロンプト 5: 具体的な実装例

```
以下のC#コードを、エンジン非依存でコンポジション優先の設計に変更してください。

現在のコード:
[具体的なファイルの内容]

要求:
1. viaエンジン固有の型を抽象化インターフェースに置き換え
2. 継承をコンポジションに変更
3. 型安全性を向上
4. テスト可能な設計に変更

制約:
- 既存の機能を維持
- パフォーマンスを考慮
- 可読性を向上

新しいコードを提供してください。
```

## プロンプト 6: テスト戦略の提案

```
以下のC#プロジェクトのテスト戦略を提案してください。

現在の問題:
- エンジン依存により単体テストが困難
- 統合テストのみで品質保証
- テストカバレッジが低い

目標:
- 各コンポーネントの単体テスト
- モックを使用したテスト
- 高いテストカバレッジ

提案してください:
1. テストアーキテクチャ
2. モック戦略
3. テストケース設計
4. CI/CD統合
```

## 使用時の注意点

1. **段階的なアプローチ**: 一度に全てを変更せず、段階的にリファクタリング
2. **既存機能の保持**: 現在の AI 機能を維持しながら改善
3. **パフォーマンス考慮**: リファクタリングによる性能劣化を避ける
4. **可読性向上**: コードの可読性と保守性を向上させる
5. **テスト駆動**: 各段階でテストを追加・実行
